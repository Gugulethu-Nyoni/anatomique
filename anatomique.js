import { writeFile, mkdir } from 'node:fs/promises';
import { join, basename } from 'node:path';
import escodegen from 'escodegen';
import { parse } from 'acorn';
import * as estraverse from 'estraverse'; // Import estraverse

// Helper for deep cloning an AST node (needed because we'll modify it)
function deepCloneAstNode(node) {
    // A simple JSON parse/stringify is usually sufficient for most ASTs
    // generated by Acorn, as long as they don't contain circular references
    // or non-JSON-serializable properties (like functions).
    return JSON.parse(JSON.stringify(node));
}

// Recursive AST transformation function
// This function will walk the AST and replace any reactive variable identifier
// with a MemberExpression that accesses its `.value` property.
function transformReactiveIdentifiersInExpression(node, isReactiveVariableFn) {
    if (!node || typeof node !== 'object' || !node.type) {
        return node;
    }

    // Process the current node
    if (node.type === 'Identifier' && isReactiveVariableFn(node.name)) {
        // If this identifier is a reactive variable, transform it to `identifier.value`
        // Ensure it's not already part of a '.value' access (though unlikely if it's a bare Identifier)
        return {
            type: 'MemberExpression',
            object: deepCloneAstNode(node), // The original identifier becomes the object
            property: { type: 'Identifier', name: 'value' },
            computed: false,
            optional: false
        };
    }

    // Recursively process children of the current node
    for (const key in node) {
        if (node.hasOwnProperty(key) && key !== 'loc' && key !== 'range' && key !== 'comments' && key !== 'tokens') {
            const value = node[key];
            if (Array.isArray(value)) {
                node[key] = value.map(item => transformReactiveIdentifiersInExpression(item, isReactiveVariableFn));
            } else if (typeof value === 'object' && value !== null) {
                node[key] = transformReactiveIdentifiersInExpression(value, isReactiveVariableFn);
            }
        }
    }
    return node;
}


export default class Anatomique {
    constructor(jsAST, cssAST, customAST, filePath) {
        this.filePath = filePath;
        this.fileName = basename(filePath, '.ast');
        this.appRootId = 'app';
        this.jsAST = jsAST;
        this.cssAST = cssAST;
        this.customAST = customAST;
        this.transpiledJSContent = [];
        this.componentCleanups = [];
        this.transpiledHTML = '';
        this.distDir = './dist';
        this.addState = true;

        this.reactiveVariables = new Set();
        this.staticVariables = new Set();

        this.globalDerivedCache = new Map(); // Map: expressionString -> varName
        this.globalDerivedDeclarations = []; // Array of actual 'const varName = $derived(...);' strings

        this.localDerivedDeclarations = null; // A temporary array for block-local deriveds

        this.analyzeJsAST(); // Populate `this.reactiveVariables` and `this.staticVariables`

        this.nodeToTranspilerMap = {
            Element: this.Element.bind(this),
            KeyValueAttribute: this.Attribute.bind(this),
            BooleanAttribute: this.Attribute.bind(this),
            EventHandler: this.Attribute.bind(this),
            TwoWayBindingAttribute: this.Attribute.bind(this),
            MustacheAttribute: this.Attribute.bind(this),
            BooleanIdentifierAttribute: this.Attribute.bind(this),
            Fragment: this.Fragment.bind(this),
            TextNode: this.TextNode.bind(this),
            MustacheTag: this.MustacheTag.bind(this),
            IfStatement: this.IfStatement.bind(this),
            EachStatement: this.EachStatement.bind(this),
        };

        this.transpiledJSContent.push(`const appRoot = document.getElementById('${this.appRootId}');\n`);

        this.traverse();

        this.output();
    }

    // --- Utility Methods ---

    analyzeJsAST() {
        // Use estraverse to walk the AST more thoroughly
        estraverse.traverse(this.jsAST.content, {
            enter: (node, parent) => {
                if (node.type === 'VariableDeclarator') {
                    const varName = node.id.name; // Assuming simple identifiers for now

                    if (node.init && node.init.type === 'CallExpression') {
                        const callee = node.init.callee;
                        // Check if it's a call to a reactivity primitive ($state, $derived, or $props)
                        if (callee.type === 'Identifier' &&
                            (callee.name === '$state' || callee.name === '$derived' || callee.name === '$props')) {
                            this.reactiveVariables.add(varName);
                            this.staticVariables.delete(varName); // Ensure it's not also marked static
                        } else {
                            // It's a function call, but not a reactivity primitive (e.g., `let x = someFunc();`)
                            if (!this.reactiveVariables.has(varName)) { // Only add if not already marked reactive
                                this.staticVariables.add(varName);
                            }
                        }
                    } else if (node.id.type === 'Identifier') {
                        // Plain variable declaration (e.g., `let x = 10;`, `const y = 'hello';`, `let z;`)
                        // Add to static variables if not already identified as reactive
                        if (!this.reactiveVariables.has(varName)) {
                            this.staticVariables.add(varName);
                        }
                    }
                }
                // Future consideration: Handle function parameters, loop variables, etc., if they could affect reactivity.
                // For now, this covers top-level `let` and `const`.
            },
        });

        // Optional: Log for debugging
        console.log("Reactive variables detected:", Array.from(this.reactiveVariables));
        console.log("Static variables detected:", Array.from(this.staticVariables));
    }

    isReactiveVariable(varName) {
        return this.reactiveVariables.has(varName);
    }

    getUniqueId(prefix = '') {
        return `${prefix}${Math.random().toString(36).slice(2, 8)}`;
    }

    // --- Helper to get/create a derived variable ---
    getOrCreateDerived(expressionCode, context = {}) {
        // If the expression contains a loop variable, we must generate a new derived
        // every time and cannot use the global cache.
        const isLoopItemInExpression = context.itemVar && expressionCode.includes(context.itemVar);
        const isGlobalScope = !this.localDerivedDeclarations;

        if (isGlobalScope && !isLoopItemInExpression && this.globalDerivedCache.has(expressionCode)) {
            return this.globalDerivedCache.get(expressionCode);
        }

        let transformedExpressionCode;
        try {
            // Parse the expression into its own mini-AST
            const parsedProgram = parse(`(${expressionCode})`, { ecmaVersion: 2020 });
            const expressionAst = parsedProgram.body[0].expression;
            // Apply the transformation using our `isReactiveVariable` checker
            const transformedAst = transformReactiveIdentifiersInExpression(expressionAst, (name) => this.isReactiveVariable(name));
            transformedExpressionCode = escodegen.generate(transformedAst);
        } catch (e) {
            console.error(`Error parsing or transforming derived expression "${expressionCode}":`, e);
            transformedExpressionCode = expressionCode; // Fallback to original code
        }

        const derivedVarName = this.getUniqueId('derived_');
        const derivedDeclaration = `const ${derivedVarName} = $derived(() => ${transformedExpressionCode});`;

        if (isGlobalScope) {
            this.globalDerivedCache.set(expressionCode, derivedVarName);
            this.globalDerivedDeclarations.push(derivedDeclaration);
        } else {
            // Store in the local block's declarations
            this.localDerivedDeclarations.push(derivedDeclaration);
        }

        return derivedVarName;
    }

    // --- Traversal Method ---
    traverse() {
        const htmlFragment = this.customAST?.content?.html;
        if (!htmlFragment || !Array.isArray(htmlFragment.children)) {
            console.warn("customAST.content.html or its children not found or not an array. No HTML to transpile.");
            return;
        }

        const customSyntaxNode = htmlFragment.children.find(
            child => child.type === 'Element' && child.name === 'customSyntax'
        );

        if (!customSyntaxNode || !Array.isArray(customSyntaxNode.children)) {
            console.error("Custom syntax wrapper element 'customSyntax' not found or has no children. Cannot transpile.");
            return;
        }

        // Pass null for itemVar and keyVar at the top level
        // Ensure customSyntaxNode.children is an array before passing.
        // This is the top-level call that might cause the initial error if customSyntaxNode.children is not an array.
        this.transpileBlock(Array.isArray(customSyntaxNode.children) ? customSyntaxNode.children : [], { parentVar: 'appRoot' });
    }

    // --- Node Transpilation Methods ---

    Element(node, parentVar, context = {}) {
        const varName = `${node.name}_elem_${this.getUniqueId()}`;

        this.transpiledJSContent.push(`const ${varName} = document.createElement("${node.name}");`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

        if (Array.isArray(node.attributes)) {
            for (const attr of node.attributes) {
                const transpileFn = this.nodeToTranspilerMap[attr.type];
                if (transpileFn) transpileFn(attr, varName, context);
            }
        }

        // --- FIX: Ensure node.children is an array before passing to transpileBlock ---
        // This prevents `TypeError: blockNodes is not iterable` if an element has no children.
        this.transpileBlock(Array.isArray(node.children) ? node.children : [], { ...context, parentVar: varName });
    }

    Fragment(node, parentVar, context = {}) {
        // --- FIX: Ensure node.children is an array before passing to transpileBlock ---
        // This prevents `TypeError: blockNodes is not iterable` if a fragment has no children.
        this.transpileBlock(Array.isArray(node.children) ? node.children : [], { ...context, parentVar: parentVar });
    }

    Attribute(attr, elementVarName, context = {}) {
        switch (attr.type) {
            case "KeyValueAttribute": {
                const attrName = attr.name;
                const attrValue = attr.value?.[0]?.data || "";
                this.transpiledJSContent.push(`${elementVarName}.setAttribute("${attrName}", ${JSON.stringify(attrValue)});`);
                break;
            }

            case "TwoWayBindingAttribute": {
                const bindVarName = attr.expression?.name; // Assumes simple Identifier for binding

                if (!bindVarName) {
                    console.error(`ERROR: Two-way binding: Missing variable name for ${attr.name} on element ${elementVarName}.`);
                    return;
                }

                if (!this.isReactiveVariable(bindVarName)) {
                    console.error(
                        `ERROR: Two-way binding (bind:${attr.name}) can only be used with reactive variables ` +
                        `(declared with $state()). '${bindVarName}' is not a reactive variable.`
                    );
                    return;
                }
                this.transpiledJSContent.push(`bind(${elementVarName}, ${bindVarName});`);
                break;
            }

            case "MustacheAttribute": {
                const dynAttr = attr.name;
                const expression = attr.expression;

                if (!expression) {
                    console.error("MustacheAttribute: Missing expression for", dynAttr);
                    return;
                }

                const dynValueCode = escodegen.generate(expression);

                const derivedAttrValueVar = this.getOrCreateDerived(dynValueCode, context);

                this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${dynAttr}", () => ${derivedAttrValueVar}.value);`);
                break;
            }

case "EventHandler": {
                const eventName = attr.name;
                const eventHandlerExpression = attr.expression; // This is the AST node for the expression

                if (!eventHandlerExpression) {
                    console.error("EventHandler: Missing expression for", eventName);
                    return;
                }

                // First, transform reactive variables within the expression itself (e.g., `count` becomes `count.value`)
                const transformedInternalExpression = transformReactiveIdentifiersInExpression(
                    deepCloneAstNode(eventHandlerExpression),
                    (name) => this.isReactiveVariable(name)
                );

                // Generate the code for the (potentially transformed) expression
                const internalHandlerCode = escodegen.generate(transformedInternalExpression);

                let finalHandlerCode;

                // Check if the expression is already an anonymous function (arrow or regular function expression)
                if (eventHandlerExpression.type === 'ArrowFunctionExpression' ||
                    eventHandlerExpression.type === 'FunctionExpression') {
                    // If it's already a function, use its generated code directly.
                    // E.g., @click={() => add(1, 3)} will be passed as `() => add(1, 3)`
                    finalHandlerCode = internalHandlerCode;
                } else if (eventHandlerExpression.type === 'Identifier') {
                    // If it's a bare identifier (e.g., `alerter`, `increment`), pass it directly.
                    // This generates `element.addEventListener("click", alerter);`
                    // The browser will call `alerter()` when clicked.
                    finalHandlerCode = internalHandlerCode;
                } else {
                    // For ALL other types of expressions (e.g., CallExpression like `toggle(true)`,
                    // BinaryExpression, MemberExpression, etc.), wrap them in an arrow function
                    // to ensure they are executed only when the event fires.
                    // This generates `element.addEventListener("click", () => { toggle(true); });`
                    finalHandlerCode = `() => { ${internalHandlerCode}; }`;
                }

                this.transpiledJSContent.push(`${elementVarName}.addEventListener("${eventName}", ${finalHandlerCode});`);
                break;
            }


            
            case "BooleanAttribute":
            case "BooleanIdentifierAttribute": {
                const attrName = attr.name;
                const attrValue = attr.value; // This could be a string (e.g., "true", "false", or var name) or AST node

                // If it's a static boolean like `disabled="true"` or `disabled`
                if (typeof attrValue === 'string' && (attrValue === 'true' || attrValue === 'false' || attrValue === '')) {
                    this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${attrValue === '' ? 'true' : attrValue});`);
                }
                // If it's an expression like `disabled={isAdmin}` or `disabled={someBooleanVar}`
                else if (attr.expression) { // This handles cases like `disabled={expression}`
                    const conditionCode = escodegen.generate(attr.expression);
                    const derivedCondition = this.getOrCreateDerived(conditionCode, context);
                    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
                }
                // Fallback for simple identifier attributes like `disabled={myReactiveVar}` directly on attr.value
                else if (typeof attrValue === 'string' && this.isReactiveVariable(attrValue)) {
                    const derivedCondition = this.getOrCreateDerived(attrValue, context);
                    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
                }
                else {
                    // Fallback for any other type (e.g., if it was a plain non-reactive `let myBool = true;`)
                    this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${!!attrValue});`);
                }
                break;
            }

            default:
                this.transpiledJSContent.push(`// Unknown attribute type: ${attr.type}`);
        }
    }

    TextNode(node, parentVar) {
        const varName = `text_node_${this.getUniqueId()}`;
        this.transpiledJSContent.push(`const ${varName} = document.createTextNode(${JSON.stringify(node.value)});`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);
    }

    MustacheTag(node, parentVar, context = {}) {
        const varName = `mustache_node_${this.getUniqueId()}`;
        this.transpiledJSContent.push(`const ${varName} = document.createTextNode('');`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

        if (!node.expression) {
            console.error("MustacheTag: Missing expression");
            return;
        }

        let expressionCode = escodegen.generate(node.expression);

        // Check if the expression is the loop item variable itself
        // This is a specific edge case / helper, might need adjustment based on desired behavior
        if (context.itemVar && expressionCode === context.itemVar) {
            console.warn(`Implicitly accessing "${context.itemVar}.name" in an #each block. It's better to be explicit: {${context.itemVar}.name}`);
            expressionCode = `${context.itemVar}.name`; // Or handle as an error if explicit is mandatory
        }

        const derivedVar = this.getOrCreateDerived(expressionCode, context);
        this.transpiledJSContent.push(`bindText(${varName}, ${derivedVar});`);
    }

    // --- Refactored Block Handling ---

    transpileBlock(blockNodes, context) {
        // --- FIX: Ensure blockNodes is iterable ---
        // This is the primary fix for `TypeError: blockNodes is not iterable`.
        // If blockNodes is null/undefined/not an array, it defaults to an empty array.
        const nodesToTranspile = Array.isArray(blockNodes) ? blockNodes : [];

        for (const child of nodesToTranspile) {
            // Skip comments
            if (child.type === 'CommentBlock') continue;

            const transpileFn = this.nodeToTranspilerMap[child.type];
            if (transpileFn) {
                transpileFn(child, context.parentVar, context);
            } else {
                console.warn(`No transpiler function found for node type: ${child.type} within a block. Node:`, child);
            }
        }
    }

    EachStatement(node, parentVar, context = {}) {
        const id = this.getUniqueId();
        const sourceCode = escodegen.generate(node.source);
        const itemVar = node.item.name;
        const keyVar = node.key ? node.key.name : null;

        // 1. Create DOM structure
        const fragmentPlaceholder = `each_placeholder_${id}`;
        const eachItemsVar = `each_items_${id}`;
        const cleanupsVar = `each_cleanups_${id}`;

        this.transpiledJSContent.push(
            `const ${fragmentPlaceholder} = document.createComment('each block');`,
            `${parentVar}.appendChild(${fragmentPlaceholder});`,
            `let ${eachItemsVar} = [];`,
            `let ${cleanupsVar} = [];`
        );

        // 2. Temporarily store and transpile the block body
        // Ensure node.body.body is an array, as `transpileBlockContent` expects it.
        const bodyNodes = Array.isArray(node.body?.body) ? node.body.body : [];
        const itemBlockData = this.transpileBlockContent(bodyNodes, { ...context, itemVar: itemVar, keyVar: keyVar });

        // 3. Generate the render function for a single item, including its local deriveds
        this.transpiledJSContent.push(
            `const render_each_item_${id} = (${itemVar}) => {`,
            ` const ${itemBlockData.fragmentVar} = document.createDocumentFragment();`,
            ` ${itemBlockData.blockDeriveds}`,
            ` ${itemBlockData.blockJS}`,
            ` return { nodes: Array.from(${itemBlockData.fragmentVar}.childNodes), cleanups: [${itemBlockData.blockCleanups}] };`,
            `};`
        );

        // 4. Create the reactive effect that re-renders the list
        this.transpiledJSContent.push(
            `$effect(() => {`,
            ` ${cleanupsVar}.forEach(fn => fn());`,
            ` ${cleanupsVar}.length = 0;`,
            ` ${eachItemsVar}.forEach(el => el.remove());`,
            ` ${eachItemsVar}.length = 0;`,
            ` const sourceArray = ${this.getOrCreateDerived(sourceCode, context)}.value ?? [];`, // <-- MODIFIED: Access .value of derived source array
            ` sourceArray.forEach((${itemVar}, index) => {`,
            `  const itemData = render_each_item_${id}(${itemVar});`,
            `  ${fragmentPlaceholder}.after(...itemData.nodes);`,
            `  ${eachItemsVar}.push(...itemData.nodes);`,
            `  ${cleanupsVar}.push(...itemData.cleanups);`,
            ` });`,
            `});`
        );
    }


    IfStatement(node, parentVar, context = {}) {
        const id = this.getUniqueId();
        const placeholderCommentVar = `if_placeholder_${id}`;

        // The condition for the if statement. Use getOrCreateDerived for the condition itself.
        const conditionCode = escodegen.generate(node.test);
        const derivedConditionVar = this.getOrCreateDerived(conditionCode, context);

        this.transpiledJSContent.push(`const ${placeholderCommentVar} = document.createComment('if block');`);
        this.transpiledJSContent.push(`${parentVar}.appendChild(${placeholderCommentVar});`);

        // --- FIX: Ensure node.consequent.body is an array ---
        const consequentNodes = Array.isArray(node.consequent?.body) ? node.consequent.body : [];
        const ifBranchData = this.transpileBlockContent(consequentNodes, context);
        const createIfFragmentFunction = `create_if_fragment_${id}`;

        this.transpiledJSContent.push(`const ${createIfFragmentFunction} = () => {`);
        this.transpiledJSContent.push(` const ${ifBranchData.fragmentVar} = document.createDocumentFragment();`);
        this.transpiledJSContent.push(ifBranchData.blockDeriveds);
        this.transpiledJSContent.push(ifBranchData.blockJS);
        this.transpiledJSContent.push(` return {`);
        this.transpiledJSContent.push(`  nodes: Array.from(${ifBranchData.fragmentVar}.childNodes),`);
        this.transpiledJSContent.push(`  cleanups: () => { ${ifBranchData.blockCleanups} }`);
        this.transpiledJSContent.push(` };`);
        this.transpiledJSContent.push(`};`);

        let createElseFragmentFunction = null;
        if (node.alternate) {
            // --- FIX: Ensure node.alternate.body is an array ---
            const alternateNodes = Array.isArray(node.alternate?.body) ? node.alternate.body : [];
            const elseBranchData = this.transpileBlockContent(alternateNodes, context);
            createElseFragmentFunction = `create_else_fragment_${id}`;

            this.transpiledJSContent.push(`const ${createElseFragmentFunction} = () => {`);
            this.transpiledJSContent.push(` const ${elseBranchData.fragmentVar} = document.createDocumentFragment();`);
            this.transpiledJSContent.push(elseBranchData.blockDeriveds);
            this.transpiledJSContent.push(elseBranchData.blockJS);
            this.transpiledJSContent.push(` return {`);
            this.transpiledJSContent.push(`  nodes: Array.from(${elseBranchData.fragmentVar}.childNodes),`);
            this.transpiledJSContent.push(`  cleanups: () => { ${elseBranchData.blockCleanups} }`);
            this.transpiledJSContent.push(` };`);
            this.transpiledJSContent.push(`};`);
        }

        this.transpiledJSContent.push(`let if_elements_${id} = [];`);
        this.transpiledJSContent.push(`let if_element_cleanups_${id} = [];`);

        this.transpiledJSContent.push(`$effect(() => {`);
        this.transpiledJSContent.push(` // Run previous cleanups (if any)`);
        this.transpiledJSContent.push(` if_element_cleanups_${id}.forEach(fn => fn());`);
        this.transpiledJSContent.push(` if_element_cleanups_${id}.length = 0;`);

        this.transpiledJSContent.push(` // Remove previous elements from DOM`);
        this.transpiledJSContent.push(` if_elements_${id}.forEach(el => el.remove());`);
        this.transpiledJSContent.push(` if_elements_${id}.length = 0;`);

        this.transpiledJSContent.push(` let fragmentData;`);
        this.transpiledJSContent.push(` if (${derivedConditionVar}.value) {`); // Access value of derived condition
        this.transpiledJSContent.push(`  fragmentData = ${createIfFragmentFunction}();`);
        this.transpiledJSContent.push(` } `);

        if (createElseFragmentFunction) {
            this.transpiledJSContent.push(`else {`);
            this.transpiledJSContent.push(`  fragmentData = ${createElseFragmentFunction}();`);
            this.transpiledJSContent.push(` }`);
        } else {
            this.transpiledJSContent.push(`else {`);
            this.transpiledJSContent.push(`  fragmentData = null;`); // Explicitly set to null if no else branch
            this.transpiledJSContent.push(` }`);
        }

        this.transpiledJSContent.push(` if (fragmentData) {`);
        this.transpiledJSContent.push(`  ${placeholderCommentVar}.after(...fragmentData.nodes);`);
        this.transpiledJSContent.push(`  if_elements_${id}.push(...fragmentData.nodes);`);
        this.transpiledJSContent.push(`  if_element_cleanups_${id}.push(fragmentData.cleanups);`);
        // --- FIX: Corrected typo `this.transpiledJSContent.transpiledJSContent.push` to `this.transpiledJSContent.push` ---
        this.transpiledJSContent.push(` }`);
        this.transpiledJSContent.push(`});`);
    }


    // This helper function is used by IfStatement and EachStatement to create a self-contained block
    transpileBlockContent(blockNodes, context = {}) {
        const originalTranspiledContent = this.transpiledJSContent;
        const originalComponentCleanups = this.componentCleanups;
        const originalLocalDeriveds = this.localDerivedDeclarations;

        this.transpiledJSContent = [];
        this.componentCleanups = [];
        this.localDerivedDeclarations = [];

        const fragmentVar = `fragmentRoot_${this.getUniqueId()}`;

        // --- FIX: Ensure blockNodes is an array before passing to transpileBlock ---
        // This makes `transpileBlockContent` robust to cases where `blockNodes` might not be an array.
        this.transpileBlock(Array.isArray(blockNodes) ? blockNodes : [], { ...context, parentVar: fragmentVar });

        const blockJS = this.transpiledJSContent.join('\n');
        const blockCleanups = this.componentCleanups.join('\n');
        const blockDeriveds = this.localDerivedDeclarations.join('\n');

        this.transpiledJSContent = originalTranspiledContent;
        this.componentCleanups = originalComponentCleanups;
        this.localDerivedDeclarations = originalLocalDeriveds;

        return {
            blockJS,
            blockCleanups,
            blockDeriveds,
            fragmentVar
        };
    }


    // --- Output Generation ---
    async output() {
        try {
            await mkdir(this.distDir, { recursive: true });

            const strippedFileName = this.filePath.replace('.ast', '');
            const finalFileName = basename(strippedFileName);
            const jsFilePath = join(this.distDir, `${finalFileName}.js`);
            // FIX START
            const htmlFilePath = join(this.distDir, 'index.html'); // Moved this line up
            // FIX END

            const originalJsCode = escodegen.generate(this.jsAST.content);

            // Capture all top-level transpiled JS content and cleanups
            const mainComponentJS = this.transpiledJSContent.join('\n');
            const mainComponentCleanups = this.componentCleanups.join('\n');

            const finalJsCode = `
${this.generateStateImports()}

// Original script content (includes $state, $derived, $props declarations)
${originalJsCode}

// Global Derived Declarations created by the transpiler
${this.globalDerivedDeclarations.join('\n')}

export function renderComponent(targetElement) {
    const fragment = document.createDocumentFragment();

    // Transpiled DOM creation and reactive effects
    ${mainComponentJS}

    // Append the fragment to the target element
    targetElement.appendChild(fragment);

    // Lifecycle management: return a cleanup function
    return () => {
        // Run all component-level cleanups
        ${mainComponentCleanups}
        // Remove all direct children added by this component
        while (targetElement.firstChild) {
            targetElement.removeChild(targetElement.firstChild);
        }
    };
}
`.trim();

            await writeFile(jsFilePath, finalJsCode, 'utf8');

            const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Semantq Output</title>
</head>
<body>
    <div id="${this.appRootId}"></div>
    <script type="module">
        import { renderComponent } from './${finalFileName}.js';

        const appRoot = document.getElementById('${this.appRootId}');
        const cleanup = renderComponent(appRoot);

        // Optional: If you had a way to unmount or re-render, you'd call cleanup()
        // For a single-page app, this might not be strictly necessary unless
        // you're dynamically loading/unloading components.
        // Example: setTimeout(cleanup, 5000); // Unmount after 5 seconds
    </script>
</body>
</html>
`.trim();

            await writeFile(htmlFilePath, htmlContent, 'utf8'); // This line now has htmlFilePath defined

            console.log(`✅ Output written to ./dist (${finalFileName}.js + index.html)`);
        } catch (err) {
            console.error('❌ Failed to write output files:', err);
        }
    }



    generateStateImports() {
        return `import { $state, $derived, $effect, bind, bindText, bindAttr, bindClass, $props } from './state/index.js';\n\n`; // Added $props
    }
}