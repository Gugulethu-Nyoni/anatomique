import { writeFile, mkdir } from 'node:fs/promises';
import { join, basename } from 'node:path';
import escodegen from 'escodegen';
import { parse } from 'acorn';

// Helper for deep cloning an AST node (needed because we'll modify it)
function deepCloneAstNode(node) {
 // A simple JSON parse/stringify is usually sufficient for most ASTs
 // generated by Acorn, as long as they don't contain circular references
 // or non-JSON-serializable properties (like functions).
 return JSON.parse(JSON.stringify(node));
}

// Recursive AST transformation function
// This function will walk the AST and replace any reactive variable identifier
// with a MemberExpression that accesses its `.value` property.
function transformReactiveIdentifiersInExpression(node, isReactiveVariableFn) {
 if (!node || typeof node !== 'object' || !node.type) {
  return node;
 }

 // Process the current node
 if (node.type === 'Identifier' && isReactiveVariableFn(node.name)) {
  // If this identifier is a reactive variable, transform it to `identifier.value`
  // Ensure it's not already part of a '.value' access (though unlikely if it's a bare Identifier)
  return {
   type: 'MemberExpression',
   object: deepCloneAstNode(node), // The original identifier becomes the object
   property: { type: 'Identifier', name: 'value' },
   computed: false,
   optional: false
  };
 }

 // Recursively process children of the current node
 for (const key in node) {
  if (node.hasOwnProperty(key) && key !== 'loc' && key !== 'range' && key !== 'comments' && key !== 'tokens') {
   const value = node[key];
   if (Array.isArray(value)) {
    node[key] = value.map(item => transformReactiveIdentifiersInExpression(item, isReactiveVariableFn));
   } else if (typeof value === 'object' && value !== null) {
    node[key] = transformReactiveIdentifiersInExpression(value, isReactiveVariableFn);
   }
  }
 }
 return node;
}


export default class Anatomique {
 constructor(jsAST, cssAST, customAST, filePath) {
  this.filePath = filePath;
  this.fileName = basename(filePath, '.ast');
  this.appRootId = 'app';
  this.jsAST = jsAST;
  this.cssAST = cssAST;
  this.customAST = customAST;
  this.transpiledJSContent = [];
  this.componentCleanups = [];
  this.transpiledHTML = '';
  this.distDir = './dist';
  this.addState = true;
  this.reactiveVariables = new Set(); // Stores names of $state and $derived variables

  this.globalDerivedCache = new Map(); // Map: expressionString -> varName
  this.globalDerivedDeclarations = []; // Array of actual 'const varName = $derived(...);' strings

  this.localDerivedDeclarations = null; // A temporary array for block-local deriveds

  this.analyzeJsAST(); // Populate `this.reactiveVariables`

  this.nodeToTranspilerMap = {
   Element: this.Element.bind(this),
   KeyValueAttribute: this.Attribute.bind(this),
   BooleanAttribute: this.Attribute.bind(this),
   EventHandler: this.Attribute.bind(this),
   TwoWayBindingAttribute: this.Attribute.bind(this),
   MustacheAttribute: this.Attribute.bind(this),
   BooleanIdentifierAttribute: this.Attribute.bind(this),
   Fragment: this.Fragment.bind(this),
   TextNode: this.TextNode.bind(this),
   MustacheTag: this.MustacheTag.bind(this),
   IfStatement: this.IfStatement.bind(this),
   EachStatement: this.EachStatement.bind(this),

  };

  this.transpiledJSContent.push(`const appRoot = document.getElementById('${this.appRootId}');\n`);

  this.traverse();

  this.output();
 }

 // --- Utility Methods ---
 analyzeJsAST() {
  const jsBody = this.jsAST.content.body;
  for (const node of jsBody) {
   if (node.type === 'VariableDeclaration') {
    for (const declaration of node.declarations) {
     if (declaration.init && declaration.init.type === 'CallExpression') {
      const callee = declaration.init.callee;
      if (callee.type === 'Identifier' && (callee.name === '$state' || callee.name === '$derived')) {
       this.reactiveVariables.add(declaration.id.name);
      }
     }
    }
   }
  }
 }

 isReactiveVariable(varName) {
  return this.reactiveVariables.has(varName);
 }

 getUniqueId(prefix = '') {
  return `${prefix}${Math.random().toString(36).slice(2, 8)}`;
 }

 // --- Helper to get/create a derived variable ---
 getOrCreateDerived(expressionCode, context = {}) {
  // If the expression contains a loop variable, we must generate a new derived
  // every time and cannot use the global cache.
  const isLoopItemInExpression = context.itemVar && expressionCode.includes(context.itemVar);
  const isGlobalScope = !this.localDerivedDeclarations;

  if (isGlobalScope && !isLoopItemInExpression && this.globalDerivedCache.has(expressionCode)) {
   return this.globalDerivedCache.get(expressionCode);
  }

  let transformedExpressionCode;
  try {
   const parsedProgram = parse(`(${expressionCode})`, { ecmaVersion: 2020 });
   const expressionAst = parsedProgram.body[0].expression;
   const transformedAst = transformReactiveIdentifiersInExpression(expressionAst, (name) => this.isReactiveVariable(name));
   transformedExpressionCode = escodegen.generate(transformedAst);
  } catch (e) {
   console.error(`Error parsing or transforming derived expression "${expressionCode}":`, e);
   transformedExpressionCode = expressionCode;
  }

  const derivedVarName = this.getUniqueId('derived_');
  const derivedDeclaration = `const ${derivedVarName} = $derived(() => ${transformedExpressionCode});`;

  if (isGlobalScope) {
   this.globalDerivedCache.set(expressionCode, derivedVarName);
   this.globalDerivedDeclarations.push(derivedDeclaration);
  } else {
   // Store in the local block's declarations
   this.localDerivedDeclarations.push(derivedDeclaration);
  }

  return derivedVarName;
 }
 // --- END NEW / UPDATED getOrCreateDerived ---

 // --- Traversal Method ---
 traverse() {
  const htmlFragment = this.customAST?.content?.html;
  if (!htmlFragment || !Array.isArray(htmlFragment.children)) {
   console.warn("customAST.content.html or its children not found.");
   return;
  }

  const customSyntaxNode = htmlFragment.children.find(
   child => child.type === 'Element' && child.name === 'customSyntax'
  );

  if (!customSyntaxNode || !Array.isArray(customSyntaxNode.children)) {
   console.error("Custom syntax wrapper element 'customSyntax' not found or has no children.");
   return;
  }

  // Pass null for itemVar and keyVar at the top level
  this.transpileBlock(customSyntaxNode.children, { parentVar: 'appRoot' });
 }

 // --- Node Transpilation Methods ---

 Element(node, parentVar, context = {}) {
  const varName = `${node.name}_elem_${this.getUniqueId()}`;

  this.transpiledJSContent.push(`const ${varName} = document.createElement("${node.name}");`);
  this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

  if (Array.isArray(node.attributes)) {
   for (const attr of node.attributes) {
    const transpileFn = this.nodeToTranspilerMap[attr.type];
    if (transpileFn) transpileFn(attr, varName, context);
   }
  }
 
  this.transpileBlock(node.children, { ...context, parentVar: varName });
 }

 Fragment(node, parentVar, context = {}) {
  this.transpileBlock(node.children, { ...context, parentVar: parentVar });
 }

 Attribute(attr, elementVarName, context = {}) {
  switch (attr.type) {
   case "KeyValueAttribute": {
    const attrName = attr.name;
    const attrValue = attr.value?.[0]?.data || "";
    this.transpiledJSContent.push(`${elementVarName}.setAttribute("${attrName}", ${JSON.stringify(attrValue)});`);
    break;
   }

   case "TwoWayBindingAttribute": {
    const bindVarName = attr.expression?.name || "undefinedVar";

    if (!this.isReactiveVariable(bindVarName)) {
     console.warn(`Two-way binding on non-reactive variable: ${bindVarName}`);
     this.transpiledJSContent.push(`${elementVarName}.value = ${bindVarName};`);
     break;
    }
    this.transpiledJSContent.push(`bind(${elementVarName}, ${bindVarName});`);
    break;
   }

   case "MustacheAttribute": {
    const dynAttr = attr.name;
    const expression = attr.expression;

    if (!expression) {
     console.error("MustacheAttribute: Missing expression for", dynAttr);
     return;
    }

    const dynValueCode = escodegen.generate(expression);

    const derivedAttrValueVar = this.getOrCreateDerived(dynValueCode, context);

    this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${dynAttr}", () => ${derivedAttrValueVar}.value);`);
    break;
   }

   case "EventHandler": {
    const eventName = attr.name;
    const eventHandlerExpression = attr.expression;

    if (!eventHandlerExpression) {
     console.error("EventHandler: Missing expression for", eventName);
     return;
    }

    const handlerCode = escodegen.generate(eventHandlerExpression);

    let finalHandlerCode;

    if (eventHandlerExpression.type === 'ArrowFunctionExpression' ||
     eventHandlerExpression.type === 'FunctionExpression') {
     finalHandlerCode = handlerCode;
    } else if (eventHandlerExpression.type === 'Identifier') {
     finalHandlerCode = `() => ${handlerCode}()`;
    } else if (eventHandlerExpression.type === 'CallExpression') {
     finalHandlerCode = `() => ${handlerCode}`;
    } else {
     finalHandlerCode = `() => ${handlerCode}`;
    }

    this.transpiledJSContent.push(`${elementVarName}.addEventListener("${eventName}", ${finalHandlerCode});`);
    break;
   }

   case "BooleanAttribute":
   case "BooleanIdentifierAttribute": {
    const attrName = attr.name;
    const attrValue = attr.value;

    if (typeof attrValue === 'string' && this.isReactiveVariable(attrValue)) {
     // For reactive variables used as boolean attributes (e.g., `disabled={isAdmin}`)
     // We need to pass the derived's value to bindAttr
     const derivedCondition = this.getOrCreateDerived(attrValue, context); // Pass context
     this.transpiledJSContent.push(`bindAttr(${elementVarName}, "${attrName}", () => ${derivedCondition}.value);`);
    } else if (typeof attrValue === 'string' && (attrValue === 'true' || attrValue === 'false')) {
     this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${attrValue});`);
    } else {
     this.transpiledJSContent.push(`${elementVarName}.toggleAttribute("${attrName}", ${!!attrValue});`);
    }
    break;
   }

   default:
    this.transpiledJSContent.push(`// Unknown attribute type: ${attr.type}`);
  }
 }

 TextNode(node, parentVar) {
  const varName = `text_node_${this.getUniqueId()}`;
  this.transpiledJSContent.push(`const ${varName} = document.createTextNode(${JSON.stringify(node.value)});`);
  this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);
 }

 MustacheTag(node, parentVar, context = {}) {
  const varName = `mustache_node_${this.getUniqueId()}`;
  this.transpiledJSContent.push(`const ${varName} = document.createTextNode('');`);
  this.transpiledJSContent.push(`${parentVar}.appendChild(${varName});`);

  if (!node.expression) {
   console.error("MustacheTag: Missing expression");
   return;
  }

  let expressionCode = escodegen.generate(node.expression);

  // Check if the expression is the loop item variable itself
  if (context.itemVar && expressionCode === context.itemVar) {
   console.warn(`Implicitly accessing "${context.itemVar}.name" in an #each block. It's better to be explicit: {${context.itemVar}.name}`);
   expressionCode = `${context.itemVar}.name`;
  }

  const derivedVar = this.getOrCreateDerived(expressionCode, context);
  this.transpiledJSContent.push(`bindText(${varName}, ${derivedVar});`);
 }

 // --- Refactored Block Handling ---

 transpileBlock(blockNodes, context) {
  for (const child of blockNodes) {
   // Skip comments
   if (child.type === 'CommentBlock') continue;

   const transpileFn = this.nodeToTranspilerMap[child.type];
   if (transpileFn) {
    transpileFn(child, context.parentVar, context);
   } else {
    console.warn(`No transpiler function found for node type: ${child.type} within a block.`);
   }
  }
 }

 EachStatement(node, parentVar, context = {}) {
  const id = this.getUniqueId();
  const sourceCode = escodegen.generate(node.source);
  const itemVar = node.item.name;
  const keyVar = node.key ? node.key.name : null;

  // 1. Create DOM structure
  const fragmentPlaceholder = `each_placeholder_${id}`;
  const eachItemsVar = `each_items_${id}`;
  const cleanupsVar = `each_cleanups_${id}`;

  this.transpiledJSContent.push(
   `const ${fragmentPlaceholder} = document.createComment('each block');`,
   `${parentVar}.appendChild(${fragmentPlaceholder});`,
   `let ${eachItemsVar} = [];`,
   `let ${cleanupsVar} = [];`
  );

  // 2. Temporarily store and transpile the block body
  const itemBlockData = this.transpileBlockContent(node.body.body, { ...context, itemVar: itemVar, keyVar: keyVar });

  // 3. Generate the render function for a single item, including its local deriveds
  this.transpiledJSContent.push(
   `const render_each_item_${id} = (${itemVar}) => {`,
   ` const ${itemBlockData.fragmentVar} = document.createDocumentFragment();`,
   // Add the locally generated deriveds here
   ` ${itemBlockData.blockDeriveds}`,
   ` ${itemBlockData.blockJS}`,
   ` return { nodes: Array.from(${itemBlockData.fragmentVar}.childNodes), cleanups: [${itemBlockData.blockCleanups}] };`,
   `};`
  );

  // 4. Create the reactive effect that re-renders the list
  this.transpiledJSContent.push(
   `$effect(() => {`,
   ` ${cleanupsVar}.forEach(fn => fn());`,
   ` ${cleanupsVar}.length = 0;`,
   ` ${eachItemsVar}.forEach(el => el.remove());`,
   ` ${eachItemsVar}.length = 0;`,
   ` const sourceArray = ${sourceCode}?.value ?? [];`, // <-- FIX IS HERE
   ` sourceArray.forEach((${itemVar}, index) => {`, // <-- AND HERE
   `  const itemData = render_each_item_${id}(${itemVar});`,
   `  ${fragmentPlaceholder}.after(...itemData.nodes);`,
   `  ${eachItemsVar}.push(...itemData.nodes);`,
   `  ${cleanupsVar}.push(...itemData.cleanups);`,
   ` });`,
   `});`
  );
 }


 IfStatement(node, parentVar, context = {}) {
  const id = this.getUniqueId();
  const placeholderCommentVar = `if_placeholder_${id}`;

  // The condition for the if statement. Use getOrCreateDerived for the condition itself.
  const conditionCode = escodegen.generate(node.test);
  const derivedConditionVar = this.getOrCreateDerived(conditionCode, context);

  this.transpiledJSContent.push(`const ${placeholderCommentVar} = document.createComment('if block');`);
  this.transpiledJSContent.push(`${parentVar}.appendChild(${placeholderCommentVar});`);

  const ifBranchData = this.transpileBlockContent(node.consequent.body, context);
  const createIfFragmentFunction = `create_if_fragment_${id}`;

  this.transpiledJSContent.push(`const ${createIfFragmentFunction} = () => {`);
  this.transpiledJSContent.push(` const ${ifBranchData.fragmentVar} = document.createDocumentFragment();`);
  this.transpiledJSContent.push(ifBranchData.blockDeriveds);
  this.transpiledJSContent.push(ifBranchData.blockJS);
  this.transpiledJSContent.push(` return {`);
  this.transpiledJSContent.push(`  nodes: Array.from(${ifBranchData.fragmentVar}.childNodes),`);
  this.transpiledJSContent.push(`  cleanups: () => { ${ifBranchData.blockCleanups} }`);
  this.transpiledJSContent.push(` };`);
  this.transpiledJSContent.push(`};`);

  let createElseFragmentFunction = null;
  if (node.alternate) {
   const elseBranchData = this.transpileBlockContent(node.alternate.body, context);
   createElseFragmentFunction = `create_else_fragment_${id}`;

   this.transpiledJSContent.push(`const ${createElseFragmentFunction} = () => {`);
   this.transpiledJSContent.push(` const ${elseBranchData.fragmentVar} = document.createDocumentFragment();`);
   this.transpiledJSContent.push(elseBranchData.blockDeriveds);
   this.transpiledJSContent.push(elseBranchData.blockJS);
   this.transpiledJSContent.push(` return {`);
   this.transpiledJSContent.push(`  nodes: Array.from(${elseBranchData.fragmentVar}.childNodes),`);
   this.transpiledJSContent.push(`  cleanups: () => { ${elseBranchData.blockCleanups} }`);
   this.transpiledJSContent.push(` };`);
   this.transpiledJSContent.push(`};`);
  }

  this.transpiledJSContent.push(`let if_elements_${id} = [];`);
  this.transpiledJSContent.push(`let if_element_cleanups_${id} = [];`);

  this.transpiledJSContent.push(`$effect(() => {`);
  this.transpiledJSContent.push(` // Run previous cleanups (if any)`);
  this.transpiledJSContent.push(` if_element_cleanups_${id}.forEach(fn => fn());`);
  this.transpiledJSContent.push(` if_element_cleanups_${id}.length = 0;`);

  this.transpiledJSContent.push(` // Remove previous elements from DOM`);
  this.transpiledJSContent.push(` if_elements_${id}.forEach(el => el.remove());`);
  this.transpiledJSContent.push(` if_elements_${id}.length = 0;`);

  this.transpiledJSContent.push(` let fragmentData;`);
  this.transpiledJSContent.push(` if (${derivedConditionVar}.value) {`); // Access value of derived condition
  this.transpiledJSContent.push(`  fragmentData = ${createIfFragmentFunction}();`);
  this.transpiledJSContent.push(` } `);

  if (createElseFragmentFunction) {
   this.transpiledJSContent.push(`else {`);
   this.transpiledJSContent.push(`  fragmentData = ${createElseFragmentFunction}();`);
   this.transpiledJSContent.push(` }`);
  } else {
   this.transpiledJSContent.push(`else {`);
   this.transpiledJSContent.push(`  fragmentData = null;`);
   this.transpiledJSContent.push(` }`);
  }

  this.transpiledJSContent.push(` if (fragmentData) {`);
  this.transpiledJSContent.push(`  ${placeholderCommentVar}.after(...fragmentData.nodes);`);
  this.transpiledJSContent.push(`  if_elements_${id}.push(...fragmentData.nodes);`);
  this.transpiledJSContent.push(`  if_element_cleanups_${id}.push(fragmentData.cleanups);`);
  this.transpiledJSContent.push(` }`);
  this.transpiledJSContent.push(`});`);
 }


 // This helper function is used by IfStatement and EachStatement to create a self-contained block
 transpileBlockContent(blockNodes, context = {}) {
  const originalTranspiledContent = this.transpiledJSContent;
  const originalComponentCleanups = this.componentCleanups;
  const originalLocalDeriveds = this.localDerivedDeclarations;

  this.transpiledJSContent = [];
  this.componentCleanups = [];
  this.localDerivedDeclarations = [];

  const fragmentVar = `fragmentRoot_${this.getUniqueId()}`;
  // this.transpiledJSContent.push(`const ${fragmentVar} = document.createDocumentFragment();`); // This will be added by the calling function

  // Call the general transpiler for the block, passing the fragment as the parent
  this.transpileBlock(blockNodes, { ...context, parentVar: fragmentVar });

  const blockJS = this.transpiledJSContent.join('\n');
  const blockCleanups = this.componentCleanups.join('\n');
  const blockDeriveds = this.localDerivedDeclarations.join('\n');

  this.transpiledJSContent = originalTranspiledContent;
  this.componentCleanups = originalComponentCleanups;
  this.localDerivedDeclarations = originalLocalDeriveds;

  return {
   blockJS,
   blockCleanups,
   blockDeriveds,
   fragmentVar
  };
 }


 // --- Output Generation ---
 // --- Output Generation ---
async output() {
 try {
 await mkdir(this.distDir, { recursive: true });

 const strippedFileName = this.filePath.replace('.ast', '');
 const finalFileName = basename(strippedFileName);
 const jsFilePath = join(this.distDir, `${finalFileName}.js`);

 const originalJsCode = escodegen.generate(this.jsAST.content);

 // Capture all top-level transpiled JS content and cleanups
 const mainComponentJS = this.transpiledJSContent.join('\n');
 const mainComponentCleanups = this.componentCleanups.join('\n');

 const finalJsCode = `
${this.generateStateImports()}

// Original script content
${originalJsCode}

// Global Derived Declarations
${this.globalDerivedDeclarations.join('\n')}

export function renderComponent(targetElement) {
  const fragment = document.createDocumentFragment();

  // Transpiled DOM creation and reactive effects
  ${mainComponentJS}

  // Append the fragment to the target element
  targetElement.appendChild(fragment);

  // Lifecycle management: return a cleanup function
  return () => {
    // Run all component-level cleanups
    ${mainComponentCleanups}
    // Remove all direct children added by this component
    while (targetElement.firstChild) {
      targetElement.removeChild(targetElement.firstChild);
    }
  };
}
`.trim();

 await writeFile(jsFilePath, finalJsCode, 'utf8');

 const htmlContent = `
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Semantq Output</title>
</head>
<body>
<div id="${this.appRootId}"></div>
<script type="module">
 import { renderComponent } from './${finalFileName}.js';

 const appRoot = document.getElementById('${this.appRootId}');
 const cleanup = renderComponent(appRoot);

 // Optional: If you had a way to unmount or re-render, you'd call cleanup()
 // For a single-page app, this might not be strictly necessary unless
 // you're dynamically loading/unloading components.
 // Example: setTimeout(cleanup, 5000); // Unmount after 5 seconds
</script>
</body>
</html>
`.trim();

 const htmlFilePath = join(this.distDir, 'index.html');
 await writeFile(htmlFilePath, htmlContent, 'utf8');

 console.log(`✅ Output written to ./dist (${finalFileName}.js + index.html)`);
 } catch (err) {
 console.error('❌ Failed to write output files:', err);
 }
}

generateStateImports() {
 return `import { $state, $derived, $effect, bind, bindText, bindAttr, bindClass } from './state/index.js';\n\n`;
}




 generateStateImports() {
  return `import { $state, $derived, $effect, bind, bindText, bindAttr, bindClass } from './state/index.js';\n\n`;
 }
}
